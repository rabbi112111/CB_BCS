# -*- coding: utf-8 -*-
"""BCS of CB prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19tXLVJPCwMHQHCerdi6YU5N193XBOKr9
"""

import pandas as pd
import numpy as np

# Set random seed for reproducibility
np.random.seed(42)

# Number of data points
n_samples = 1000

# Generate random data for each feature
flute_types = np.random.choice(['A', 'B', 'C', 'E'], size=n_samples)  # Random flute types
liner_thickness = np.random.uniform(0.1, 0.5, size=n_samples)  # Liner thickness in mm
box_length = np.random.uniform(100, 600, size=n_samples)  # Box length in mm
box_width = np.random.uniform(100, 600, size=n_samples)  # Box width in mm
box_height = np.random.uniform(100, 600, size=n_samples)  # Box height in mm
material_density = np.random.uniform(250, 450, size=n_samples)  # Material density in kg/m³

# Generate synthetic Box Compression Strength (BCS) with some random noise
# BCS is dependent on dimensions, liner thickness, and material density
BCS = (0.2 * liner_thickness + 0.003 * (box_length + box_width + box_height) + 0.01 * material_density +
       np.random.normal(0, 0.05, size=n_samples))

# Create a DataFrame
df = pd.DataFrame({
    'flute_type': flute_types,
    'liner_thickness': liner_thickness,
    'box_length': box_length,
    'box_width': box_width,
    'box_height': box_height,
    'material_density': material_density,
    'BCS': BCS
})

# Display the first few rows of the dataset
print(df.head())

# Save the dataset to a CSV file
df.to_csv('synthetic_corrugated_box_data.csv', index=False)



from google.colab import files
uploaded = files.upload()



import pandas as pd

# Load the dataset
df = pd.read_csv('synthetic_corrugated_box_data.csv')

# Display the first few rows
print(df.head())

from sklearn.preprocessing import LabelEncoder

# Initialize the label encoder
label_encoder = LabelEncoder()

# Apply label encoding to the 'flute_type' column
df['flute_type_encoded'] = label_encoder.fit_transform(df['flute_type'])

# Drop the original 'flute_type' column (since we have the encoded version now)
df = df.drop('flute_type', axis=1)

# Check the first few rows of the updated dataset
print(df.head())

from sklearn.model_selection import train_test_split

# Define the features (X) and target (y)
X = df.drop('BCS', axis=1)  # Features: all columns except 'BCS'
y = df['BCS']  # Target: 'BCS'

# Split the dataset into training (80%) and testing (20%) sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Check the shapes of the training and testing sets
print(X_train.shape, X_test.shape)

from sklearn.ensemble import RandomForestRegressor

# Initialize the Random Forest Regressor
rf = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model on the training data
rf.fit(X_train, y_train)

# Make predictions on the test set
y_pred = rf.predict(X_test)

from sklearn.metrics import mean_squared_error, r2_score

# Calculate the Mean Squared Error (MSE)
mse = mean_squared_error(y_test, y_pred)

# Calculate the R-squared (R²) score
r2 = r2_score(y_test, y_pred)

# Print the evaluation metrics
print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

import matplotlib.pyplot as plt

# Plot the predicted vs actual BCS values
plt.scatter(y_test, y_pred)
plt.xlabel("Actual BCS")
plt.ylabel("Predicted BCS")
plt.title("Actual vs Predicted Box Compression Strength")
plt.show()

import joblib

# Save the model to a file
joblib.dump(rf, 'random_forest_bcs_model.pkl')

from flask import Flask, request, jsonify
import joblib
import pandas as pd

# Initialize the Flask app
app = Flask(__name__)

# Load the trained model
model = joblib.load('random_forest_bcs_model.pkl')

@app.route('/predict', methods=['POST'])
def predict():
    # Get the data from the request (assuming JSON format)
    data = request.get_json()

    # Convert the data into a pandas DataFrame
    df = pd.DataFrame([data])

    # Preprocess the data (e.g., encoding the categorical variable)
    df['flute_type_encoded'] = label_encoder.transform(df['flute_type'])
    df = df.drop('flute_type', axis=1)

    # Make predictions
    prediction = model.predict(df)

    # Return the prediction as a JSON response
    return jsonify({'BCS': prediction[0]})

if __name__ == '__main__':
    app.run(debug=True)